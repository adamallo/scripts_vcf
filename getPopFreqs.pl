#!/usr/bin/perl -w
use strict;
use warnings;
use Getopt::Long qw(GetOptions);
Getopt::Long::Configure qw(gnu_getopt);
use Bio::DB::HTS::Tabix;

##Configuration variables
######################################################
my $IFS="\t";
my $OFS="\t";
my $AFS=","; ##Allele separation
######################################################

##IO Variables
######################################################
my $pop_file="";
my $input_folder="";
my $output_file="";
my $n_cores=1;

#Flags
my $help;
my $usage="Usage: $0 -p populationDataVCFWith_Tabix -c n_cores -i folder -o summary_output.tsv\n\n This script takes a main folder generated by HeterAnalyzer and obtains population allele frequency information for each folder. It generates one summary file, indicated by the user with -o, and also one output per folder, with a VCF-like file. The name of these is fixed, A_withPAF.tsv, B_withPAF.tsv, and C_withPAF.tsv\n";
######################################################

######################################################
##MAIN
######################################################

##Getopt
######################################################
(! GetOptions(
	'population_file|p=s' => \$pop_file,
    'input_folder|i=s' => \$input_folder,
    'output_file|o=s' => \$output_file,
    'n_cores|c=i' => \$n_cores,
    'help|h' => \$help,
                )) or (($output_file eq "") || ($input_folder eq "")  || ($pop_file eq "") || $help) and die $usage;


##Input file parsing and directory creation
######################################################

-s $pop_file && -s "${pop_file}.tbi" or -s die "The file with population data, $pop_file cannot be read or does not have the proper tabix format";

##Load Parallel::Loops if it is available and it's needed
#########################################################

if($n_cores>1)
{
    eval "use Parallel::Loops";
    if($@)
    {
        print "\n\nWARNING: You are asking to execute this script using $n_cores cores, but the required module \"Parallel::Loops\" has not been found in \@INC\n\n";
         $n_cores=1;
   }
    else
    {
        print "\nUsing Parallel::Loops with $n_cores cores\n\n";
    }
}
else
{
    $n_cores=1;
}

##Main program
my %results;
my $parallel;

if ($n_cores>1)
{
    $parallel = Parallel::Loops->new($n_cores);
    $parallel->share(\%results);
}

my @dictfiles =<$input_folder/*/vcfdict.csv>;

if($n_cores>1 && scalar @dictfiles > 1)
{
    $parallel->foreach(\@dictfiles,\&getPopAFReplicate);
}
else
{
   foreach my $dictfile (@dictfiles)
   {
        getPopAFReplicate($dictfile);
   }
}

open(my $OUTPUT,">$output_file") or die "The outputfile $output_file cannot be opened";
print($OUTPUT "Case${OFS}A_private_PAFgt5${OFS}A_private_PAFgt25${OFS}B_private_PAFgt5${OFS}B_private_PAFgt25${OFS}Common_PAFgt5${OFS}Common_PAFgt25${OFS}\n");
foreach my $case (keys %results)
{
    #print("DEBUG: $case,$results{$case}\n");
    print($OUTPUT join($OFS,$case,@{$results{$case}},"\n"));
}
close($OUTPUT);
exit;

sub getPopAFReplicate
{
    my $vcflist;
    my $case;
    my $path;

    my $tabix = Bio::DB::HTS::Tabix->new( filename =>$pop_file );
    
    if (defined $_)
    {
        $case=$_;
    }
    else
    {
        $case=$_[0];
    }

    $vcflist=$path=$case;
    $case =~ s/^.*\/([^\/]*)\/vcfdict.csv/$1/;
    $path =~ s/^(.*\/)vcfdict.csv/$1/;
    
    my @vcfcontent;
    open(my $IFILE, $vcflist) or die "Error opening the file $vcflist";
    @vcfcontent=<$IFILE>;
    close($IFILE);

    my $afile;
    my $bfile;
    my $cfile;

    foreach my $line (@vcfcontent)
    {   
        if($line=~/AfiltcovBNAB.*different.vcf/)
        {
            $afile=$line;
        }
        elsif($line=~/BfiltcovBNAB.*different.vcf/)
        {
            $bfile=$line;
        }
        elsif($line=~/filtcovBNABU.*common.vcf/)
        {
            $cfile=$line;
        }
    }

    $afile=~s/.*,//;
    $bfile=~s/.*,//;
    $cfile=~s/.*,//;

    my @aResults= getPopFile($path.$afile,"A",$tabix);
    my @bResults= getPopFile($path.$bfile,"B",$tabix);
    my @cResults= getPopFile($path.$cfile,"C",$tabix);

    #print("DEBUG: returned values @aResults, @bResults, @cResults\n");
    $results{$case}=[@aResults,@bResults,@cResults];
}

sub getPopFile
{
    my ($file,$fileid,$tabix)=@_;    
    #print("DEBUG: $file\n");
    open(my $FILEHANDLE, $file) or die "The input file $file does not exist or cannot be read";
    my @input_data=<$FILEHANDLE>;
    close($FILEHANDLE);

    my $thisoutput_file=$file;
    $thisoutput_file=~s/[^\/]+$/${fileid}_withPAF.tsv/;
    open(my $THISOUTPUT_FILE, ">$thisoutput_file") or die "The output file $thisoutput_file cannot be opened";
    print($THISOUTPUT_FILE "#CHROM\tPOS\tREF\tALT\tFILTER\tAF\n");
    
    my $i=0;
    my $chr="";
    my $nstart=0;
    my $tstart=0;
    my $nend="";
    my $ref="";
    my $tref="";
    my $ialt="";
    my $talt="";
    my $tfilt="";
    my $taf=0;
    my $tabix_iter;
    my %pop_data;
    my $nlt25=0;
    my $nlt5=0;
    my $n=0;

    for ($i=0; $i<scalar @input_data; ++$i) 
    {
        if($input_data[$i]=~m/^[^#]/)
        {
            my @linecontent=split($IFS,$input_data[$i]);
            $chr=$linecontent[0];
            $nstart=$linecontent[1];
            $ref=$linecontent[3];
            my @alt=split($AFS,$linecontent[4]);
            
            #print("DEBUG: $chr $nstart $ref @alt\n");
            #print("DEBUG: "."$chr:$nstart-".($nstart+1));
            $tabix_iter=$tabix->query("$chr:$nstart-".($nstart+1));
            
            if(defined $tabix_iter)
            { 
                %pop_data=();
                while(my $line=$tabix_iter->next)
                {
                    #CHROM  POS ID  REF ALT QUAL    FILTER  INFO    FORMAT  S1 ... SN
                    $line =~ s/^[^\t]+\t([^\t]+)\t[^\t]+\t([^\t]+)\t([^\t]+)\t[^\t]+\t([^\t]+)\t[^\t]+AF=([^;]+).*$/$1\t$3\t$2\t$4\t$5/;
                    #print("DEBUG: $line\n");
                    ($tstart,$talt,$tref,$tfilt,$taf)=split($IFS,$line);
                    #print("DEBUG: $tstart, $talt, $tref, $tfilt, $taf\n");
                    $pop_data{"${tstart}_$talt"}=[$tref,$tfilt,$taf];
                }
               
            }
            else
            {
                warn "There is no data for $chr:$nstart-".($nstart+1);
            }
            foreach $ialt (@alt) 
            {
                if(exists $pop_data{"${nstart}_$ialt"}){
                   print($THISOUTPUT_FILE "$chr$OFS$nstart$OFS$ref$OFS$ialt$OFS".$pop_data{"${nstart}_$ialt"}[1].$OFS.$pop_data{"${nstart}_$ialt"}[2]."\n");
                    if($pop_data{"${nstart}_$ialt"}[2]>0.05){
                        if($pop_data{"${nstart}_$ialt"}[2]>0.25){
                            ++$nlt25;
                        }
                        ++$nlt5;
                    }
                }
                else
                {
                   print($THISOUTPUT_FILE "$chr$OFS$nstart$OFS$ref$OFS$ialt${OFS}NA${OFS}NA\n"); 
                }
                ++$n;
            }
        }
        
    } 
    close($THISOUTPUT_FILE);

    my $flt5="NA";
    my $flt25="NA";
    if($n!=0)
    {
        $flt5=$nlt5/($n*1.0);
        $flt25=$nlt25/($n*1.0);
    }
    #print("DEBUG: return values $flt5, $flt25\n");
    return($flt5,$flt25);
}

