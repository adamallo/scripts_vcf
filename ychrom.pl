use strict;
use warnings;
use local::lib;
use Bio::DB::Sam;
use Bio::DB::Sam::Constants;
use Bio::FeatureIO;
use Data::Dumper;
use Env;

##Conf
our $mapq=20;
our $max_mapq=5;
our $phred=20;
our $private="-p private";
our $qsub_nonparallel="sbatch ${private} -N 1 -n 1 -c 1 --mem=10000";
our $qstat="qstat";
our $sed='sed "s/Submitted batch job \(.*\)/\1/"';
our $map_sh="remap.sh";
our $SCRIPTSVCF_DIR=$ENV{'SCRIPTSVCF_DIR'};

#Data
my $par1_start=10001;
my $par1_end=2649520;
my $par3_start=2926383;
my $par3_end=6543100;
my $par2_start=59034050;
my $par2_end=59363566;

##IO
my $usage="$0 bamfile FASTA(refgenome) FASTA(refgenome_noY) bed_file min_mapq max_mapq_reject dir outname\n\n
This script calculates the percentage of the total well aligned read pairs (0x008 SAM tag) over certain mapping quality threshold that map to the Y chromosome\n";
my $bamfile="";
my $fasta="";
my $fasta_y="";
my $bedfile="";
my $outdir="";
my $outname="";

if (scalar @ARGV != 8 || ! -f $ARGV[0] || ! -f $ARGV[1] || ! -f $ARGV[2] || ! -f $ARGV[3] || ! -d $ARGV[6])
{
  die $usage;
}
else
{
    ($bamfile,$fasta,$fasta_y,$bedfile,$mapq,$max_mapq,$outdir,$outname)=@ARGV;
}

my $sam = Bio::DB::Sam->new(-bam  => $bamfile, -fasta=> $fasta, -expand_flags=>1);
my $bam = Bio::DB::Bam->open($bamfile,"r"); ##Opening with the low-level API to get the header
my $header=$bam->header();
my @ids = $sam->seq_ids();
my $job_id;
my %job_ids;

#my @total = $sam->get_features_by_location(-type=> 'read_pair');
#my $unfiltered_total_pairs=scalar(@total);
#@total=();
#print("Total, memory usage should drop now\n");


##Total filtered reads
######################
my $filtered_total_pairs=0;

#foreach my $region (@ids)
#{
#    my @filtered_total = $sam->get_features_by_location(-type=>'read_pair',-seq_id=>$region,-filter => \&filter);
#    $filtered_total_pairs+=scalar(@filtered_total);
##    print("DEBUG: adding ",scalar(@filtered_total),"alignments to the total\n");
#    @filtered_total=();
#}

#my @pairs = $sam->get_features_by_location(-type=>'read_pair',-seq_id => 'Y');
#my $unfiltered_y_pairs=scalar(@pairs);
#@pairs=();

##Filtered reads chromosome Y
#############################
#print("\nFiltering chromosome Y reads:");
my @filtered_y = $sam->get_features_by_location(-type=>'read_pair',-seq_id => 'Y',-filter => \&filter);
#print("DEBUG: before cleaning ",scalar @filtered_y,"\n");
clean_unpaired(\@filtered_y);
#print("DEBUG: after cleaning ",scalar @filtered_y,"\n");
my $filtered_y_pairs=scalar(@filtered_y);

my $filtered_y_reads_noy=0;

#print(" Done\nWriting $filtered_y_pairs mate pairs to bam:");

if($filtered_y_pairs != 0)
{
    #Bam realignment
    write_to_bam("$outdir/${outname}_filtered_y.bam",$header,@filtered_y);
    $job_id=`$qsub_nonparallel $map_sh $fasta $fasta_y "$outdir/${outname}_filtered_y.bam" | $sed`;
    chomp($job_id);
    $job_ids{$job_id}=1;
}

#print(" Done\nFiltering non-PAR chromosome Y reads:");

##Filtered reads non-PAR chromosome Y
#####################################

#Defining the regions to look for variants
my @excluded_regions=([$par1_start,$par1_end],[$par3_start,$par3_end],[$par2_start,$par2_end]); #ordered array of anonymous arrays (array refs generated by [])
my @final_regions=([1,$sam->length("Y")]);
@final_regions=substract_regions(\@final_regions,\@excluded_regions);


my @filtered_nonpar;
foreach my $region (@final_regions)
{
    my $start=${$region}[0];
    my $end=${$region}[1];
    push(@filtered_nonpar,$sam->get_features_by_location(-type=>'read_pair',-seq_id => 'Y',-start=>$start,-end=>$end,-filter => \&filter));
    #print("DEBUG: adding another region of filtered nonpar, current number of alignments ",scalar(@filtered_nonpar),"\n");
}
clean_unpaired(\@filtered_nonpar);
my $filtered_nonpar_pairs=scalar @filtered_nonpar;
my $filtered_nonpar_reads_noy=0;

#print(" Done\nWriting $filtered_nonpar_pairs mate pairs to bam:");

if($filtered_nonpar_pairs !=0)
{
    #Bam realignment
    write_to_bam("$outdir/${outname}_filtered_nonpar.bam",$header,@filtered_nonpar);
    $job_id=`$qsub_nonparallel $map_sh $fasta $fasta_y "$outdir/${outname}_filtered_nonpar.bam" | $sed`;
    chomp($job_id);
    $job_ids{$job_id}=1;
}

#print(" Done\nFiltering bed non-PAR chromosome Y reads:");
#print("$unfiltered_y_pairs read pairs aligned to the Y chromosome\n");

##Filtered reads non-PAR BED chromosome Y
#########################################

my $bed = Bio::FeatureIO->new(-file => $bedfile, -format => 'bed');
my @bed_regions;

#print("Debug:entering the loop\n");

while (my $entry = $bed->next_feature())
{
    if ($entry->seq_id =~ m/Y/)
    {
        push(@bed_regions,[$entry->start,$entry->end]);
    }
}

#print("DEBUG: BED regions: ");
#foreach my $ref (@bed_regions)
#{
#    print(${$ref}[0],", ",${$ref}[1],"; ");
#}
#print("\n");

@bed_regions=substract_regions(\@bed_regions,\@excluded_regions);

my @filtered_bed_nonpar;
foreach my $region (@bed_regions)
{
    my $start=${$region}[0];
    my $end=${$region}[1];
    push(@filtered_bed_nonpar,$sam->get_features_by_location(-type=>'read_pair',-seq_id => 'Y',-start=>$start,-end=>$end,-filter => \&filter));
#print("DEBUG: adding another region of filtered nonpar, current number of alignments ",scalar(@filtered_nonpar),"\n");
}
clean_unpaired(\@filtered_bed_nonpar);
my $filtered_bed_nonpar_pairs=scalar @filtered_bed_nonpar;

my $filtered_bed_nonpar_reads_noy=0;

#print(" Done\nWriting $filtered_bed_nonpar_pairs mate pairs to bam:");

if ($filtered_bed_nonpar_pairs != 0)
{
#Bam realignment
    write_to_bam("$outdir/${outname}_filtered_bed_nonpar.bam",$header,@filtered_bed_nonpar);
    $job_id=`$qsub_nonparallel $map_sh $fasta $fasta_y "$outdir/${outname}_filtered_bed_nonpar.bam" | $sed`;
    chomp($job_id);
    $job_ids{$job_id}=1;
}

#print(" Done\n");

##Analyzing the remapped reads
###############################

wait_for_jobs();

if ($filtered_y_pairs != 0)
{
    my $sam_filtered_noy=Bio::DB::Sam->new(-bam  => "$outdir/${outname}_filtered_y_noY.bam", -fasta=> $fasta_y, -expand_flags=>1);
    my $sam_filtered_y=Bio::DB::Sam->new(-bam  => "$outdir/${outname}_filtered_y_withY.bam", -fasta=> $fasta, -expand_flags=>1);
    my @filtered_y_noy= $sam_filtered_noy->features(-type=>"read_pair",-filter=>\&filter_bad);
    my @filtered_y_y= $sam_filtered_y->features(-type=>"read_pair",-filter=>\&filter_bad);
    my @filtered_y_final_reads=filter_compare_bam(\@filtered_y_noy,\@filtered_y_y);
    $filtered_y_reads_noy=scalar @filtered_y_final_reads;
    
}

if ($filtered_nonpar_pairs != 0)
{
    my $sam_filtered_nonpar_noy=Bio::DB::Sam->new(-bam  => "$outdir/${outname}_filtered_nonpar_noY.bam", -fasta=> $fasta_y, -expand_flags=>1);
    my $sam_filtered_nonpar_y=Bio::DB::Sam->new(-bam  => "$outdir/${outname}_filtered_nonpar_withY.bam", -fasta=> $fasta, -expand_flags=>1);
    my @filtered_nonpar_noy= $sam_filtered_nonpar_noy->features(-type=>"read_pair",-filter=>\&filter_bad);
    my @filtered_nonpar_y= $sam_filtered_nonpar_y->features(-type=>"read_pair",-filter=>\&filter_bad);
    my @filtered_nonpar_final_reads=filter_compare_bam(\@filtered_nonpar_noy,\@filtered_nonpar_y);
    $filtered_nonpar_reads_noy=scalar @filtered_nonpar_final_reads;
}

if ($filtered_bed_nonpar_pairs != 0)
{
    my $sam_filtered_bed_nonpar_noy=Bio::DB::Sam->new(-bam  => "$outdir/${outname}_filtered_bed_nonpar_noY.bam", -fasta=> $fasta_y, -expand_flags=>1);
    my $sam_filtered_bed_nonpar_y=Bio::DB::Sam->new(-bam  => "$outdir/${outname}_filtered_bed_nonpar_withY.bam", -fasta=> $fasta, -expand_flags=>1);
    my @filtered_bed_nonpar_noy= $sam_filtered_bed_nonpar_noy->features(-type=>"read_pair",-filter=>\&filter_bad);
    my @filtered_bed_nonpar_y= $sam_filtered_bed_nonpar_y->features(-type=>"read_pair",-filter=>\&filter_bad);
    my @filtered_bed_nonpar_final_reads=filter_compare_bam(\@filtered_bed_nonpar_noy,\@filtered_bed_nonpar_y);
    $filtered_bed_nonpar_reads_noy=scalar @filtered_bed_nonpar_final_reads;
}

#print("Total,CHRY,CHRY-NOY,CHRY-NONPAR,CHRY-NONPAR-NOY,CHRY-NONPAR-BED,CHRY-NONPAR-BED-NOY\n");
my $filtered_total_reads=2*$filtered_total_pairs;
my $filtered_y_reads=2*$filtered_y_pairs;
my $filtered_nonpar_reads=2*$filtered_nonpar_pairs;
my $filtered_bed_nonpar_reads=2*$filtered_bed_nonpar_pairs;

print("$filtered_total_reads,$filtered_y_reads,$filtered_y_reads_noy,$filtered_nonpar_reads,$filtered_nonpar_reads_noy,$filtered_bed_nonpar_reads,$filtered_bed_nonpar_reads_noy\n");
#print("$filtered_y_pairs paired reads aligned to the Y chromosome with MAPQ >= $mapq\n");
#print($filtered_y_pairs/($filtered_total_pairs+0.0)," percentage of total reads with MAPQ >= $mapq in Y \n");


##Subrutines
###########
sub filter
{
  my $read=shift;
  my $filter=0;
  if($read->get_tag_values(FLAGS->{0x0002}) == 1 && $read->get_tag_values(FLAGS->{0x0100}) == 0 && $read->get_tag_values(FLAGS->{0x0200}) == 0 && $read->get_tag_values(FLAGS->{0x0400}) == 0 && $read->get_tag_values(FLAGS->{0x0800})== 0)
  {
    if($read->qual >= $mapq) #MAPQ
    {
      #Phred scores, commented out for now
#       my @baseqs=$read->qscore;
#       foreach my $baseq (@baseqs)
#       {
#         if ($baseq<$phred)
#         {
#           $filter=0;
#           last;
#         }
#       }
      $filter=1;
    }
  }
  return $filter;

}

sub filter_bad
{
  my $read=shift;
  my $filter=0;
  if($read->get_tag_values(FLAGS->{0x0100}) == 0 && $read->get_tag_values(FLAGS->{0x0200}) == 0 && $read->get_tag_values(FLAGS->{0x0400}) == 0 && $read->get_tag_values(FLAGS->{0x0800})== 0) #Primary alignments
  {
    if(($read->get_tag_values(FLAGS->{0x0004}) == 1 || $read->get_tag_values(FLAGS->{0x0008}) == 1) || $read->qual <= $max_mapq) #If this read or its pair are unmapped or it has a really low mapping quality
    {
      $filter=1;
      #print("DEBUG:",$read->get_tag_values(FLAGS->{0x0004}),", ",$read->get_tag_values(FLAGS->{0x0008}),", ",$read->qual," \n");
    }
  }
  return $filter;

}

sub clean_unpaired
{
    my ($ref_alignments)=@_;
    my @tags0;
    my @tags1;
    for (my $i=scalar(@{$ref_alignments})-1; $i>=0;--$i)
    {
        my $pair=${$ref_alignments}[$i];
        my @ends=$pair->get_SeqFeatures;
        my $splice=1;
        if (scalar(@ends) == 2)
        {
            @tags0=($ends[0]->get_tag_values(FLAGS->{0x0040}),$ends[0]->get_tag_values(FLAGS->{0x0080}));
            @tags1=($ends[1]->get_tag_values(FLAGS->{0x0040}),$ends[1]->get_tag_values(FLAGS->{0x0080}));
            if (($tags0[0]!=$tags1[0]) && ($tags0[1] != $tags1[1]))
            {
                $splice=0;
            }
        }
        if($splice)
        {
            splice(@{$ref_alignments},$i,1);
        }
        else
        {
            #print("DEBUG: number of reads ",scalar @ends," tags0 @tags0, tags1 @tags1, ",$ends[0]->query->name,",",$ends[1]->query->name,"\n");
        }
    }
}

sub substract_regions
{   
    my ($ref_final_regions,$ref_excluded_regions)=@_;
    my @excluded_regions=@{$ref_excluded_regions};
    my @final_regions=@{$ref_final_regions};
    my $start_e=0;
    my $end_e=0;
    my $start_o=0;
    my $end_o=0;
    
    foreach my $reg_to_exclude (@excluded_regions)
    {
        $start_e=${$reg_to_exclude}[0];
        $end_e=${$reg_to_exclude}[1];
#        print("DEBUG: reg to exclude $start_e, $end_e\n");
        my @original_final_regions=@final_regions;
        @final_regions=();
        for (my $i=0;$i<scalar(@original_final_regions);++$i)
        {
#            print("\tExternal loop, original regions=",scalar @original_final_regions,"\n");
            #my $reg=$final_regions[$i];
            my $reg=$original_final_regions[$i];
            $start_o=${$reg}[0];
            $end_o=${$reg}[1];
#            print("\tDEBUG: modifying region $start_o, $end_o\n");
            if($start_e<=$start_o && $end_e>=$end_o) ###eliminate this element of the array
            {
#                print("\t\tDEBUG: removing this original region (not copying it)");
                #splice(@final_regions,$i,1);
            }
            elsif ($start_e>$start_o && $end_e<$end_o) ###Split segment in two
            {
#                print("\t\tDEBUG: Split old: ",${$reg}[0],",",${$reg}[1],"; new: ",${$reg}[0],",",$start_e-1,";","$end_e+1, $end_o\n");
                my @new=($end_e+1,$end_o);
                ${$reg}[1]=$start_e-1;
                push(@final_regions,$reg);
                push(@final_regions,\@new);
                #splice(@final_regions,$i+1,0,\@new);
            }
            elsif ($start_e<=$start_o && $end_e>$start_o)##Prune from the left
            {
#                print("\t\tDEBUG: changing the left side of the fragment from ",${$reg}[0],"to $end_e+1\n");
                ${$reg}[0]=$end_e+1;
                push(@final_regions,$reg);
            }
            elsif($end_e>=$end_o && $start_e<$end_o)##Prune from the right
            {
#                print("\t\tDEBUG: changing the right side of the fragment from",${$reg}[1],"to $start_e-1\n");
                ${$reg}[1]=$start_e-1;
                push(@final_regions,$reg);
            }
            else
            {
                push(@final_regions,$reg);
            }
#            print("\tDEBUG: final regions= ",scalar @final_regions,"\n");
        }
    }
    
    #DEBUG
#    foreach my $reg (@final_regions)
#    {
#        print("start= ",${$reg}[0],"end= ",${$reg}[1],";");
#    }
#    print("\n");
    return(@final_regions);
}

#Procedure to create a new bam file, sort and index it
######################################################
sub write_to_bam
{    
    my $bamfile=shift;
    my $header=shift;
    my @alignments=@_;
   
    #Touch bam file
    open (my $FILE,">$bamfile");
    print($FILE "");
    close($FILE);
    
    my $outbam=Bio::DB::Bam->open("$bamfile","w");
    $outbam->header_write($header);
#    print("DEBUG: writing header\n"); 
    foreach my $pair (@alignments)
    {
        my @ends = $pair->get_SeqFeatures;
        if(scalar @ends != 2)
        {
            print(STDERR "Warning: Only one read of this alignment has passed the quality control\n");
        }

        foreach my $read (@ends)
        {
            if($outbam->write1($read->{"align"}) == 0)
            {
                die "Error writing an alignment to the output BAM file $bamfile\n";
            }
#            else
#            {
#                print("DEBUG: number of reads ",scalar @ends,",",$ends[0]->query->name,",",$ends[1]->query->name,"\n");
#            }
        }
    }
}

sub wait_for_jobs
{
    my $awk='awk \'BEGIN{FS=" ";var=1}{if ($5 != "C"){var=0}}END{print var}\'';
    while (scalar keys %job_ids != 0)##Check
    {
        sleep(5);
#        print("\tPending jobs ",join(",",keys %job_ids),"\n");
        foreach my $id (keys %job_ids)
        {
            my $status=`$qstat $id | tail -n 1 | $awk`;
            #print("DEBUG: Status job id $id : $status\n");
            if($status==1) ## 1 means that the job has finished
            {
                delete($job_ids{$id});
            }
        }
    }
}

sub filter_compare_bam
{
    my ($refproblem,$refcontrol)=@_;
    my %control=%{array_pairs_to_hash_alignments($refcontrol)};
    my %problem=%{array_pairs_to_hash_alignments($refproblem)};
    
#    print("DEBUG: control keys: ");
#    foreach my $key (keys %control)
#    {
#        print("$key, ");
#    }
#    print("\n");
#    print("DEBUG: problem keys: ");
#    foreach my $key (keys %problem)
#    {
#        print("$key, ");
#    }
#    print("\n");

    foreach my $key (keys %problem)
    {
        if(exists $control{$key})
        {
            delete $problem{$key};
        }
    }
    return values %problem;
}

sub array_pairs_to_hash_alignments
{
    my %hash;
    foreach my $pair (@{$_[0]})
    {
        my @ends= $pair->get_SeqFeatures;
        for (my $i=1; $i<=scalar @ends;++$i)
        {
            $hash{$ends[$i-1]->query->name . "\/$i"}=$ends[$i-1];
        }
    }
    return \%hash;
}
