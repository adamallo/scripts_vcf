use warnings;
use strict;

#Configuration variables
my $OFS="\t";
my $IFS="\t";
my $MFS=",";
my $todelete="T-H_SL-DCIS64-";##ATTENTION, HARDCODED

#Flags
my $help;

my $usage="Usage: $0 inputfile.tree inputfile.meg inputfile.txt outputfile\n The first input file corresponds to the reconstructed tree, the second to the *.meg file and the third the *.txt file generated by clonefinder. The last is the output file.\n";
######################################################

######################################################
##MAIN
######################################################

##Getopt
if (scalar @ARGV != 4 ||! -f $ARGV[0] || ! -f $ARGV[1] || ! -f $ARGV[2])
{
	die "ERROR: problem parsing input files.\n$usage";
}

mopen(my $FH_INFILE,$ARGV[0]);
my ($tree)=<$FH_INFILE>;
close($FH_INFILE);

mopen($FH_INFILE,$ARGV[1]);
my @clonedata=<$FH_INFILE>;
close($FH_INFILE);

mopen($FH_INFILE,$ARGV[2]);
my @inputdata=<$FH_INFILE>;
close($FH_INFILE);

shift @clonedata;

my @cloneNamesAlignment;
my %cloneNameToNumberAlignmentMap;
my $irootclone;
my $minmuts=9**9**9;

my $iclone=0;
my $line;

#We store clone names in an array and a hash and find the clone with the least mutations
for (my $iline=0; $iline< scalar @clonedata; ++$iline)
{
	$line=$clonedata[$iline];
	if ($line =~ /^#/)
	{
		chomp($line);
		$line =~s/#//;
		push(@cloneNamesAlignment,$line);
		$cloneNameToNumberAlignmentMap{$line}=$iclone;
		$line=$clonedata[$iline+1];
		chomp($line);
		$line=~s/A//g;
		if (length $line < $minmuts)
		{
			$irootclone=$iclone;
			$minmuts=length $line;
		}
		$iclone++;
	}
}

chomp($inputdata[0]);
my @cloneNamesFreqs=split("\t",shift @inputdata);
shift @cloneNamesFreqs;
my @content;
my $sample;
my %cloneNameNumberAlignmentToArraySamplesMap;
foreach my $line (@inputdata)
{
	chomp($line);
	@content=split($IFS,$line);
	$sample=shift @content;
	for ($iclone=0; $iclone<scalar @content; ++$iclone)
	{
		if($content[$iclone] != 0)
		{
			my $cloneName="Clone".$cloneNameToNumberAlignmentMap{$cloneNamesFreqs[$iclone]};
			if(exists $cloneNameNumberAlignmentToArraySamplesMap{$cloneName})
			{
				push(@{$cloneNameNumberAlignmentToArraySamplesMap{$cloneName}},"C$cloneNameToNumberAlignmentMap{$cloneNamesFreqs[$iclone]}\@$sample:0");
			}
			else
			{
				$cloneNameNumberAlignmentToArraySamplesMap{$cloneName}=["C$cloneNameToNumberAlignmentMap{$cloneNamesFreqs[$iclone]}\@$sample:0"];
			}
		}

	}
}

foreach my $key (keys %cloneNameNumberAlignmentToArraySamplesMap)
{
	my $rep="(".join(",",@{$cloneNameNumberAlignmentToArraySamplesMap{$key}}).")";
	$tree=~s/$key([^@])/$rep$1/;
}

$tree=~s/$todelete//g;

mopen(my $OUT_TREE, ">$ARGV[3]");
print $OUT_TREE $tree;
close($OUT_TREE);

#DEBUG:
#foreach my $clone (keys %cloneNameNumberAlignmentToArraySamplesMap)
#{
#	print("$clone:".join(",",@{$cloneNameNumberAlignmentToArraySamplesMap{$clone}})."\n");
#}

print("Root clone: Clone$irootclone\n");
exit;

#My subrutines
##############

#sub write_FASTA_file
#{
#    my ($filename,$refdata,$refvars)=@_; 
#    mopen(my $OUT_MSA, ">$filename");
#
#    my @int_v;
#    my @sortedvars=nat_i_sorter{@int_v=split($OFS,$_);$int_v[0],$int_v[1]} keys %$refvars;
#    my @refs;
#    my @alts;
#    my @finalvars;
#    my @thisdata;
#
#    #Making a list of references and alternates to be used to print later
#    #Also filtering out INDELS  
#    foreach my $var (@sortedvars)
#    {
#        @thisdata=split($OFS,$var);
#        if(length $thisdata[2] == length $thisdata[3]) #INDEL filter
#        {
#            push(@finalvars,$var);
#            push(@refs,$thisdata[2]);
#            push(@alts,$thisdata[3]);
#        }
#    }
#
#    #Fake normal
#    print($OUT_MSA ">Normal\n");
#    for (my $ivar=0; $ivar<scalar @finalvars; ++$ivar)
#    {
#        print($OUT_MSA $refs[$ivar]);
#    }
#    
#    for (my $isample=0; $isample<$nsamples; ++$isample)
#    {
#        print($OUT_MSA "\n>$samplename[$isample]\n");
#        for (my $ivar=0; $ivar<scalar @finalvars; ++$ivar)
#        {
#            if($refdata->[$isample]->{$finalvars[$ivar]}->[0]=~/1/)
#            {
#                print($OUT_MSA $alts[$ivar]);
#            }
#            elsif($refdata->[$isample]->{$finalvars[$ivar]}->[0]=~/\?/)
#            {
#                print($OUT_MSA "?");
#            }
#            else
#            {
#                print($OUT_MSA $refs[$ivar]);
#            }
#        }
#    }
#    
#    close($OUT_MSA);
#}

##THESE SUBRUTINES SHOULD PROBABLY BE PART OF MY OWN MODULE/LIBRARY

# Parse vcf returning a hash reference with keys in the form CHROM$OFSPOS$OFSREF$OFSALT and value = array_ref [genotype (coded as 0/0, 0/1, 1/0, or 1/1),$nref+$nalt, $nref, $nalt]
##########################################################################
sub parse_vcf
{
    my ($vcf1_file)=@_;
    open(my $VCF1,$vcf1_file) or die "The file $vcf1_file cannot be opened";
    my @vcf1=<$VCF1>;
    close($VCF1);
    my $flag=0;
    my $i;
    my %hash;
    my $key;
    my $value;

    for ($i=0;$i<scalar @vcf1;$i++)
    {
        unless($flag==0 and $vcf1[$i]=~/^#/)
        {
            if ($flag==0)
            {
                $flag=1;
            }
            chomp($vcf1[$i]);
            $key=$value=$vcf1[$i];
            $key=~s/^([^\t]+)\t([^\t]+)\t[^\t]\t([^\t]+)\t([^\t]+)\t.*/$1$OFS$2$OFS$3$OFS$4/;
            $value=[(split(":",(split($IFS,$value))[9]))[0,4,5]];
            $value->[3]=$value->[2];
            $value->[2]=$value->[1]-$value->[3];
            $hash{$key}=$value;
        }
    }
    return \%hash;
}

# Parses a TSV file (covN or covB), returning a reference to a hash with a key indicating each variant and the value an array reference to [number of total reads, number of reference reads, number of alternative reads]
# TODO: ATTENTION: We can have multiple-SNV here. I think this should not be like that. I should eliminate the multiple-SNVs in the VCF file. Right now this would change all the covB filter structure and therefore I am patching it up here. If I fix it in the other place, I should remove the separation of mutiple alternatives here
sub parse_tsv
{
    my ($file)=@_;
    mopen(my $FT, $file);
    my @content=<$FT>;
    close($FT);
    my %hash;
    my ($chr, $pos, $ref, $alt, $nref, $nalt);
    foreach my $line (@content)
    {
        chomp($line);
        my @biallelicSNVs=separateTriallelic($line);
        foreach my $snv (@biallelicSNVs)
        {
            ($chr, $pos, $ref, $alt, $nref, $nalt)=split($IFS,$snv);
            $hash{join($OFS,$chr,$pos,$ref,$alt)}=[$nref+$nalt, $nref, $nalt];
        }
    }
    return \%hash;
}

# TODO: ATTENTION: We can have multiple-SNV here. I think this should not be like that. I should eliminate the multiple-SNVs in the VCF file. Right now this would change all the covB filter structure and therefore I am patching it up here. If I fix it in the other place, I should remove the separation of mutiple alternatives here
sub separateTriallelic
{
    my ($line)=@_;
    my @columns=split($IFS,$line);
    my @alts=split($MFS,$columns[3]);
    my @nalts=split($MFS,$columns[5]);
    scalar @alts != scalar @nalts and die "ERROR: tsv input with different number of alternative variants and information on the number of alternative reads\n";
    my @outcontent;
    for (my $i=0; $i<scalar @alts; ++$i)
    {
        push(@outcontent,join($IFS,@columns[0..2],$alts[$i],$columns[4],$nalts[$i]));
    }
    
    return @outcontent;
}

# Writes a vcf with the variables contained in a hash selected from another VCF file
# ##################################################################################

sub write_variant_vcf
{
    my ($ref_hash,$filename,$vcf,$comment)=@_;
    open(my $OFILE, ">$filename") or die "ERROR: The file $filename could not be opened for writting";
    open(my $IFILE, "$vcf");
    my @icontent= <$IFILE>;
    close($IFILE);
    my $flag=0;
    my %hash=%{$ref_hash};
    my $key;

    #Copying the header and adding a new line with filtering info
    #Then adding the variants that are present in the hash.
    for(my $i=0;$i< scalar @icontent; ++$i)
    {
        if ($flag==0 and $icontent[$i]=~/^##/)
        {
            print($OFILE $icontent[$i]);
        }
        elsif($flag==0)
        {
            print($OFILE "$comment\n$icontent[$i]");
            $flag=1;
        }
        else
        {
            $key=$icontent[$i];
            chomp($key);
            $key=~s/^([^\t]+)\t([^\t]+)\t[^\t]\t([^\t]+)\t([^\t]+)\t.*/$1$OFS$2$OFS$3$OFS$4/;
            #print("DEBUG: Key $key\n");
            if(exists $hash{$key})
            {
                print($OFILE $icontent[$i]);
                delete($hash{$key});
            }
            if(scalar keys %hash == 0)
            {
                last;
            }

        }

    }
    close $OFILE;
}

# Parses the sample names from a VCF and returns an array with them

sub get_sample_names_vcf
{
    my ($vcfname)=@_;
    my @names;
    
    mopen(my $FT, $vcfname);
    my @content=<$FT>;
    close($FT);
    
    foreach my $line (@content)
    {
        if($line =~m/^#[^#]/)
        {
            chomp($line);
            @names=split($IFS,$line);
            splice(@names,0,9);
            last;
        }
    }
    return @names;
}

# Open with error message
###################################################################################
sub mopen
{
    open($_[0],$_[1]) or die "ERROR: impossible to open the file $_[1] in ".($_[1]=~m/^>/?"write":"read")."mode\n";
    return $_[0];
}

